## V8下的垃圾回收机制

**只要是仍处于被引用状态的堆内存数据，都不会被垃圾回收清除**
V8实现了准确式垃圾回收，采用分代式垃圾回收机制，V8将内存分为新生代和老生代两部分。
垃圾回收机制是浏览器自动的行为，我们不能控制。

## 新生代算法

新生代中的**对象存活时间比较短**，一般采用**Scavenge GC算法**。在新生代空间中，将内存分为From空间和To空间,必定有一个空间使用，一个空间空闲的。新分配的对象会存入From空间，当From空间已满的时候，新生代垃圾回收就会启动，算法检查From空间的对象，将失活的对象进行销毁，还存活的对象复制To空间中，当复制完成后将From空间和To空间互换，这样垃圾回收便结束了。

## 老生代算法

老生代中的**对象存活时间比较长且数量比较多**，一般采用**标记清除法和标记压缩法**进项垃圾回收。
- 何时对象会出现在老生代空间中？
  1. 新生代中的对象已经经历过一次Svavenge算法，会从新生代空间移到老生代空间
  2. To空间对象的占比超过25%,在这种情况下，为了不影响内存分配，会讲对象从新生代空间移动到老生代空间。

## 引用计数

如果变量被引用，引用的次数+1，引用变量的东西引用了其他变量，则此变量引用次数-1，当变量引用的次数为0时，进行垃圾回收。
缺点：循环引用，引用次数永远不为1，但其实变量已经不再使用，所以会造成内存无法被回收，造成内存泄漏。主要存在IE浏览器中，IE浏览器只要涉及COM（主要指BOM和DOM）对象，就会存在循环引用。
```
var element = document.getElementById("some_element"); // DOM元素
var myObject = new Object(); // JS对象
//循环引用
myObject.element = element;
element.someObject = myObject;
```
解决办法，将变量赋值为null，使其回收
```
myObject.element = null;
element.someObject = null;
```

## 标记清除法

1. 垃圾收集器找到所有的根，并标记它们
2. 然后他遍历并标记来自它们的所有引用
3. 然后它遍历标记的对象并标记它们的引用，所有被遍历的对象都会被记住，一面将来再次遍历到同一个对象
4. 如此操作，直到所有可达的引用被访问到
5. 没有标记的队形都会被删除

## 变量回收

- 全局变量，页面关闭，就会被回收
- 局部变量，函数执行完，就会被回收
- 局部变量，被外界引用，并不会随着函数的执行完而被回收（闭包）
  ```
  function f(){
    let o = {}
  }
  function f1(){
    let o1 = {}
    return o1
  }
  var a = f() //a=f()其实是等于f()的返回值return
  var a1 = f1()
  //f为o分配了内存，但随着f执行完，内存也会被释放。
  //f1为o分配了内存，并且把其作为返回值赋值给a1，则f1执行完，o1还被a1引用，所以不会被垃圾回收
  ```

## 内存泄漏

- 全局变量
- 未被销毁的定时器和回调函数

