# 性能优化

## 网络相关

## DNS预解析

可以通过预解析的方式得到域名的IP地址
```
<link rel = "dns-prefetch" href = "//baidu.com">
```

## 缓存

1. 使用缓存可以降低资源的重复加载，从而提高页面的记载速度。
2. 缓存分类：
   - 强缓存
   - 协商缓存
3. 强缓存： 缓存器件浏览器不需要请求服务器。state code = 200
   expires: HTTP1.0的产物，表示在一定的事件点过期，缺点：受本地时间的限制，修改了本地时间，缓存无效。
   cache-control:HTTP1.1的产物，表示在事件间隔后过期，优先级高于expires。
4. 协商缓存：需要浏览器和服务器的共同实现，发送请求，返回304
   Last-Modified：表示本地文件最后修改的日期。if-modified-since会将last-modified的值发送给服务器，询问文件是否有更新。缺点：本地文件真实打开但未修改也会视为更新。
   Etag：询问本地文件是否有变更.if-none-match会将etag的值发送给服务器，询问文件是否有变更。
5. 选择合适的缓存
   - 对于不需要缓存的资源使用cache-control：no-cache，表示不需要缓存
   - 对于频繁变动的资源，可以使用cache-control并配合Etag使用。
   - 对于文件代码来说，使用cache-control：max-age=31536000,并配合缓存策略使用.

## HTTP2.0多路复用

浏览器限制并发请求，并且TCP连接的建立是缓慢的，加载大的文件，时间消耗较多。使用HTTP2.0可以实现多路复用，建立一个TCP连接，可以发送多个请求，极大地加速了请求的速度，而且HTTP2.0支持header压缩，进一步完善了请求数据的大小。

## 预加载

预加载其实就是声明式的fetch，可以强制浏览器请求资源，并且不会阻塞onload事件，预加载在一定程度上可以优化首屏加载时间。
开启预加载
```
<link ref = "preload" href = url>
```

## 预渲染

预渲染，可以使下载的文件先在后台渲染成功。
开始预渲染
```
<link ref = "prerender" href = url>
```

## 优化渲染过程

- 懒执行：将某些逻辑推迟到使用时在计算，可以优化首屏加载速度，懒执行需要定时器或事件唤醒。
- 懒加载：将不关键的资源延后加载。（原理：只加载可是区域）

## 文件优化

- 图片优化：图片大小优化(减少像素的调色板)，图片加载优化（小图使用base64/PNG，照片使用JPEG，将多个小icon整合到一张图片上。）
- 其他文件优化（css放在head中，JS放在底部.）
- 静态文件采用CDN引入

## webpack性能优化

webpack是一个模块打包器，可以使用它管理项目中的模块依赖，并编译输出模板所需的静态文件。
1. 减少webpack打包时间
   - 优化loader ：限制打包的文件，include:仅js文件可以打包。并且编译后的文件可以使用缓存cacheDirectory。
   - HappyPack：因为node是单线程的，webpack打包也是单线程的。HappyPack可以将loader的同步执行改为并行。
   - DlLPlugin：可以将类库提前打包然后引入，也实现将公共代码抽离成单独的文件。
   - 代码压缩：使用webpack-parallel-uglify-plugin来并行运行ugLifyJS，在webpack4这个，只需要将node设置为production即可。
2. 减少webpack打包后的文件体积
   - 按需加载:将每个路由页面单独打包成一个文件。
   - Scope Hoisting：会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中。
   - Tree shaking：可以实现删除项目中未被引用的代码。
3. loader：加载器：可以让webpack有加载和解析非JS文件的能力。
4. plugin：插件，扩展webpack的功能。
5. plugin:
   - CommonsChunkPlugin:提取公共代码，提高打包效率。
   - ProvidePlugin:自动加载模块，代替Import、extends
   - html-webpack-plugin:根据模板自动生成HTML代码。
   - define-plugin：配置全局变量，
   - happypack
   - extract-text-webpack-plugin：根据模板自动生成HTML代码。

