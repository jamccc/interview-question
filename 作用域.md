# 作用域

## JS作用域

JS作用域为访问的变量，函数及对象的集合。
JS作用域，决定了变量，函数及对象的可见性和生命周期。
分类：
  1. 全局作用域
  2. 函数作用域
  3. 块级作用域(ES6)

## 全局作用域

拥有全局作用域的对象，变量及函数，可以在任何地方被访问到。全局变量在页面关闭后销毁。
1. 函数外及{}外定义的变量，就成为全局变量.
  ```
  var a = "全局变量a"
  function f(){
    console.log(a)
  }
  f()
  // a 为全局变量，可以在任何地方被访问到，所以函数f执行，可以打印出a
  ```
2. 函数内部未声明值赋值的变量，因为变量提升，也成为了全局变量。
   ```
   function f(){
     a = '函数内赋值但未定义'
   }
   f() //一定要存在
   console.log(a)
   //当函数执行时，变量a存在变量提升,成为全局变量，任何地方都可以访问到
   ```
3. var的变量提升，只会提升到当前作用域前，而不是全局作用域前.
   ```
   function f(){
     var a = "var定义的a"
   }
   f()
   console.log(a) //报错a未定义
   ```

## 局部作用域

定义在函数中的变量，拥有的就是局部作用域，每次函数调用的时候，都会产生一个全新的局部作用域，也就是说同名变量可以在不同的作用域中，并且是不可以互相访问的。函数执行完，局部变量会自动销毁。
```
function f(){
  var a = '局部作用域'
  console.log(a) //正常访问
}
f()
console.log(a) //报错 
```

## 块级作用域let / const

- 变量提升：变量声明在执行任何代码之前处理。
  ```
  console.log(foo)
  var foo = 'i am'
  function foo(){}
  ```
  变量声明---
  ```
  function foo(){}
  console.log(foo)
  foo = 'i am' 
  ```
  所以最后打印的结果为function foo(){}
  1. 函数声明被提升到最顶上；
  2. 声明只进行一次，因此后面var foo='i am koala'的声明会被忽略。
  3. 函数声明的优先级优于变量声明，且函数声明会连带定义一起被提升（这里与变量不同）
- 使用let声明的变量，只在let命令的代码块内有效。变量不会提升。
    ```
    console.log(a)
    let a = 'nihao' //报错
    ```
    好处：不会造成全局变量污染，比较易于维护。

## 作用域链

- JS执行图
  ![JS执行图](https://github.com/lhalou/interview-question/blob/master/JS%E6%89%A7%E8%A1%8C%E5%9B%BE)
- 分析阶段
  1. 分析函数声明
  2. 分析函数的参数
  3. 分析变量的声明
- 执行阶段
  在当前作用域查找x，如果有就使用，没有的话上上一级作用域查找，直到查找完所有的作用域还是没找到，抛出错误。
  **AO上如果有与函数名同名的属性,则会被此函数覆盖**
  ```
  function a(age) {
    console.log(age);  //function age(){}
    var age = 20
    console.log(age); //20
    function age() {
    }
    console.log(age); //20
  }
    a(18);
  ```
- 作用域链
  JS上每一个函数在执行的时候，会先在自己创建的AO属性上查找对应的值，如果找不到就在父级AO属性上找，还找不到继续上一层级找，直到找到全局作用域，这个AO链就是作用域链。


## LHS和RHS特性

- 都会在所有作用域中查询
- 严格模式下，找不到所需的变量时，引擎都会抛出ReferenceError异常。
- 非严格模式下，LHR稍微比较特殊: 会自动创建一个全局变量
- 查询成功时，如果对变量的值进行不合理的操作，比如：对一个非函数类型的值进行函数调用，引擎会抛出TypeError异常

  
  

