# 原型

JavaScript是没有类的概念的，都是基于原型的。ES6中的class也只是语法糖。

## 原型链

JavaScript只有一种结构就是对象。每个实例对象都有一个私有属性（__proto__）指向其构造函数的原型对象(prototype)。该对象也有一个自己的原型对象(__proto__),层层向上，直到对象的原型对象为null。此称为原型链，原型链最后的节点为null。

## 继承属性

JavaScript试图访问一个对象的属性的时候，不仅会在该对象上查找，还会在该对象的原型上，甚至原型的原型上查找，直到找到符合的属性或者找到了原型链的末端。
```
function f(){
  this.a = 1;
  this.b = 2;
}
var f1 = new f()
f.prototype.b = 3;
f.prototype.c = 4;
console.log(f1.a) //1
console.log(f1.b) // 2 虽然原型上也有b = 3,但存在属性覆盖，先查找自身才会查找原型，自身已有，直接打印2
console.log(f1.c) // 4  原型链上属性  
console.log(f1.d) // undefined  都未找到
```

## 继承方法

在JavaScript中，任何函数都可以添加到对象中，作为对象的属性。**当继承的函数被调用时，this指向的是继承对象，而不是当前继承对象所在的原型对象。**
```
var o = {
  a: 1,
  f: function(){
    console.log(this.a)
  }
}
o.f() //this为o 1
var q = Object.create(o) //q是o的继承对象
q.f() //this为q，因为q继承了o，所以有f()方法 1
```

## 使用new关键字 可以实现继承

每个实例对象f1，都有一个__proto__属性，指向他的构造函数f的prototype
```
var f = function(){}
f.prototype.sun = '继承'
var f1 = new f()
console.log(f1.__proto__ === f.prototype) //true
console.log(f.prototype)
console.log(f1.__proto__)
```
![f1.__proto__ === f.prototype](https://github.com/lhalou/interview-question/blob/master/images/%E5%8E%9F%E5%9E%8B%E9%93%BE1.PNG)


